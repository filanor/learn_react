import { CharacterPage } from "../react-got/src/components/Pages";

/**
 * 
 *  Свойства по умолчанию и компоненты высшего порядка
 * 
 *  NPM Prop-types
 *  https://www.npmjs.com/package/prop-types
 * 
 * 
 *  Проверка типов с помощью PropTypes
 *  https://ru.reactjs.org/docs/typechecking-with-proptypes.html
 * 
 *  HOC (Компоненты высщего порядка)
 *  https://medium.com/@karafizi/%D0%BF%D0%BE%D1%81%D1%82%D0%B8%D0%B3%D0%B0%D0%B5%D0%BC-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE-%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4-87ecfad848e5
 * 
 * 


Пропсам можно задавать параметры по умолчанию:
Задаются они в виде объекта (пример из got)
 */

ItemList.defaultProps = {
    onItemSelected: () => {}
}

/* Так же можно посмотреть пример использования в RandomChar - там по умолчанию задан интервал обновления
(можно задавать эти значения через static, как это сейчас там реализованно. Тогда объявление идет в самом классе. Но это еще не стандарт
   и может быть принято в ES9) 
*/

/*Проверка типов: Пример из  RandomChar (got). В setInterval() второй параметр должен быть цифрой, иначе он будет игнориться и
интервал установится в 10vkc& Мы можем проверять тип (с помощью propTypes) и сообщать об ошибках, например: */

RandomChar.propTypes = {
   interval: (props, propName, componentName) => { // (все пропсы, название нужного пропса, название компонента)
       const value = props[propName];              // Получаем значение пропса

       if( typeof value === 'number' && !isNaN(value) ) {
           return                                  // Если все ок то выходим из проверки с помощью return
       }

       return new TypeError(`${componentName}: ${propName} must be a number`); // Если ошибка типа - выводим в консоль сообщение о ней
   }
}


/** Но в реакте есть библиотека для работы с propTypes  (с ее помощью реализована проверка в RandomItem)*/



/*****************************************************
 *  Компоненты высшего порядка (HOC)
 *****************************************************/

// Функции могут возвращать функции, напримеh:
const f = (a) => {
   console.log(a);
   return (b) => {
       console.log(a+b);
     }
}
f(1)(2);  // Вызывать такую функцию надо как f(a)(b)

// Но из функции мы можем вернуть и класс:
const f = () => {
   return ItemList;
} 
// Создали функцию обертку, и если ее экспортировать вместо IteList, все будет работать
// Но функция может возвращать безымянный класс:
const f = () => {
   return class extends Component {
       componentDidMount() {
           console.log(this.props)
       }
       
       render () {
           return <h1>Привет</h1>
       }
   }
}

// Мы экспортируем этот компонент в другие, и он сохраняет пропсы






/*****************************************************
 *                Маршрутизация
 *****************************************************/
//
// Осуществляется с помощью библиотеки react-router
//  для ее работы нужно содержимое обернуть в <BrowserRouter></BrowserRouter>
// И дальше для страниц  использовать Route. Ему передается 2 параметра : Путь и компонент
<Route path = '/characters' component = {CharacterPage}/>

//Для того что бы задать ссылки на эти элементы нужно импортировать использовать Link:
<Link to = '/Books'>Ссылка</Link>

// Динамические пути. Когда мы серфим - может кликнуть на товар и откроется отдельная страница с этим товаром
// Возьмем для примера раздел с книгами. Мы хотим что бы при клике на книгу открывалась страница с этой книгой, при этом 
// в url  было ../books/номер_книги. Для этого нужно создать еще один Route
<Route path = '/books/:id' />

// так же необходимо добавть exact к 
<Route path = '/books' exact component = {BookPage}/>
// делается это что бы когда мы переходим на книгу не отображался сам каталог



// У библиотеки react-router есть 3 полезных параметра, которые можно передать в функции (match, location, history)
<Route path = '/books/:id' render = {
    ({match, location, history}) => {
        return <BookItem/>
    }
}/>

// match - объект с информацией о том как path совпал  с текущим адресом. Он же содержит параметр id
// location - состояние и положение нашего роутера в текущий момент
// history -API для организации перехода между страницами
